use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};

use anyhow::bail;
use async_trait::async_trait;
use colored::Colorize;
use meshtastic::protobufs::from_radio::PayloadVariant;
use meshtastic::protobufs::mesh_packet::PayloadVariant as MeshPayload;
use meshtastic::protobufs::{PortNum, Waypoint};
use meshtastic::types::MeshChannel;
use meshtastic::Message;
use serde::Serialize;

use super::{resolve_destination, Command, CommandContext, DestinationSpec};

// ── WaypointSendCommand ─────────────────────────────────────────

pub struct WaypointSendCommand {
    pub latitude: f64,
    pub longitude: f64,
    pub name: String,
    pub description: String,
    pub destination: DestinationSpec,
    pub icon: Option<String>,
    pub expire_hours: Option<u32>,
    pub channel: MeshChannel,
    pub locked: bool,
    pub json: bool,
}

#[derive(Serialize)]
struct WaypointSendJson {
    id: u32,
    name: String,
    latitude: f64,
    longitude: f64,
    #[serde(skip_serializing_if = "Option::is_none")]
    description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    icon: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    expire: Option<u32>,
    dest: String,
    status: String,
}

#[async_trait]
impl Command for WaypointSendCommand {
    async fn execute(&self, ctx: &mut CommandContext) -> anyhow::Result<()> {
        let (dest, dest_label) = resolve_destination(&self.destination, &ctx.node_db)?;

        let lat_i = (self.latitude * 1e7) as i32;
        let lon_i = (self.longitude * 1e7) as i32;

        let icon = self
            .icon
            .as_ref()
            .map(|s| s.chars().next().unwrap_or('\0') as u32)
            .unwrap_or(0);

        let expire = self
            .expire_hours
            .map(|h| {
                SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_secs() as u32
                    + h * 3600
            })
            .unwrap_or(0);

        let locked_to = if self.locked {
            ctx.node_db.my_node_num()
        } else {
            0
        };

        let waypoint = Waypoint {
            id: 0, // auto-generated by send_waypoint
            latitude_i: Some(lat_i),
            longitude_i: Some(lon_i),
            expire,
            locked_to,
            name: self.name.clone(),
            description: self.description.clone(),
            icon,
        };

        if !self.json {
            println!(
                "{} Sending waypoint '{}' ({}, {}) to {}...",
                "->".cyan(),
                self.name.bold(),
                self.latitude,
                self.longitude,
                dest_label.bold()
            );
        }

        ctx.api
            .send_waypoint(&mut ctx.router, waypoint, dest, true, self.channel)
            .await?;

        if self.json {
            let result = WaypointSendJson {
                id: 0,
                name: self.name.clone(),
                latitude: self.latitude,
                longitude: self.longitude,
                description: if self.description.is_empty() {
                    None
                } else {
                    Some(self.description.clone())
                },
                icon: self.icon.clone(),
                expire: if expire > 0 { Some(expire) } else { None },
                dest: dest_label,
                status: "sent".to_string(),
            };
            println!("{}", serde_json::to_string_pretty(&result)?);
        } else {
            println!("{} Waypoint sent.", "ok".green());
        }

        Ok(())
    }
}

// ── WaypointDeleteCommand ───────────────────────────────────────

pub struct WaypointDeleteCommand {
    pub id: u32,
    pub destination: DestinationSpec,
    pub channel: MeshChannel,
    pub json: bool,
}

#[async_trait]
impl Command for WaypointDeleteCommand {
    async fn execute(&self, ctx: &mut CommandContext) -> anyhow::Result<()> {
        let (dest, dest_label) = resolve_destination(&self.destination, &ctx.node_db)?;

        // Deletion convention: send waypoint with expire = 1 (epoch past)
        let waypoint = Waypoint {
            id: self.id,
            expire: 1,
            ..Default::default()
        };

        if !self.json {
            println!(
                "{} Deleting waypoint {} on {}...",
                "->".cyan(),
                self.id,
                dest_label.bold()
            );
        }

        ctx.api
            .send_waypoint(&mut ctx.router, waypoint, dest, true, self.channel)
            .await?;

        if self.json {
            println!(
                "{}",
                serde_json::json!({
                    "id": self.id,
                    "dest": dest_label,
                    "status": "deleted"
                })
            );
        } else {
            println!("{} Waypoint {} deleted.", "ok".green(), self.id);
        }

        Ok(())
    }
}

// ── WaypointListCommand ─────────────────────────────────────────

pub struct WaypointListCommand {
    pub timeout_secs: u64,
    pub json: bool,
}

#[derive(Serialize)]
struct WaypointJson {
    id: u32,
    name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    description: Option<String>,
    latitude: f64,
    longitude: f64,
    #[serde(skip_serializing_if = "Option::is_none")]
    icon: Option<String>,
    expire: u32,
    locked_to: u32,
    from: String,
}

#[async_trait]
impl Command for WaypointListCommand {
    async fn execute(&self, ctx: &mut CommandContext) -> anyhow::Result<()> {
        if !self.json {
            println!(
                "{} Listening for waypoints for {}s... Press {} to stop.\n",
                "->".cyan(),
                self.timeout_secs,
                "Ctrl+C".bold()
            );
        }

        let start = Instant::now();
        let timeout = Duration::from_secs(self.timeout_secs);
        let mut count = 0u32;

        loop {
            let remaining = timeout.saturating_sub(start.elapsed());
            if remaining.is_zero() {
                break;
            }

            let packet = tokio::time::timeout(remaining, ctx.packet_receiver.recv()).await;

            match packet {
                Err(_) => break,
                Ok(None) => bail!("Disconnected while listening for waypoints"),
                Ok(Some(from_radio)) => {
                    let Some(PayloadVariant::Packet(mesh_pkt)) = from_radio.payload_variant else {
                        continue;
                    };
                    let Some(MeshPayload::Decoded(ref data)) = mesh_pkt.payload_variant else {
                        continue;
                    };
                    if data.portnum != PortNum::WaypointApp as i32 {
                        continue;
                    }

                    let Ok(wp) = Waypoint::decode(data.payload.as_slice()) else {
                        continue;
                    };

                    count += 1;
                    let from_label = format!("!{:08x}", mesh_pkt.from);
                    let lat = wp.latitude_i.unwrap_or(0) as f64 / 1e7;
                    let lon = wp.longitude_i.unwrap_or(0) as f64 / 1e7;

                    if self.json {
                        let entry = WaypointJson {
                            id: wp.id,
                            name: wp.name.clone(),
                            description: if wp.description.is_empty() {
                                None
                            } else {
                                Some(wp.description.clone())
                            },
                            latitude: lat,
                            longitude: lon,
                            icon: if wp.icon > 0 {
                                char::from_u32(wp.icon).map(|c| c.to_string())
                            } else {
                                None
                            },
                            expire: wp.expire,
                            locked_to: wp.locked_to,
                            from: from_label,
                        };
                        println!("{}", serde_json::to_string(&entry)?);
                    } else {
                        let icon_str = if wp.icon > 0 {
                            char::from_u32(wp.icon)
                                .map(|c| format!(" {}", c))
                                .unwrap_or_default()
                        } else {
                            String::new()
                        };
                        println!(
                            "  {} [{}]{} from {}",
                            format!("#{}", wp.id).bold(),
                            wp.name,
                            icon_str,
                            from_label
                        );
                        println!("     {:<16} {:.7}, {:.7}", "position:".dimmed(), lat, lon);
                        if !wp.description.is_empty() {
                            println!("     {:<16} {}", "description:".dimmed(), wp.description);
                        }
                        if wp.expire > 0 {
                            println!("     {:<16} {}", "expire:".dimmed(), wp.expire);
                        }
                        if wp.locked_to > 0 {
                            println!("     {:<16} !{:08x}", "locked_to:".dimmed(), wp.locked_to);
                        }
                        println!();
                    }
                }
            }
        }

        if !self.json {
            println!(
                "{} Received {} waypoint(s) in {}s.",
                "ok".green(),
                count,
                self.timeout_secs
            );
        }

        Ok(())
    }
}
